(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{208:function(i,_,t){"use strict";t.r(_);var l=t(0),v=Object(l.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var i=this,_=i.$createElement,t=i._self._c||_;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"solid-원칙"}},[i._v("SOLID 원칙")]),i._v(" "),t("h2",{attrs:{id:"srp-단일-책임-원칙"}},[i._v("SRP : 단일 책임 원칙")]),i._v(" "),t("ul",[t("li",[i._v("Single Responsibility Principle")]),i._v(" "),t("li",[i._v("객체는 오직 하나의 책임을 가져야 한다.")])]),i._v(" "),t("h2",{attrs:{id:"ocp-개방-폐쇄-원칙"}},[i._v("OCP : 개방 - 폐쇄 원칙")]),i._v(" "),t("ul",[t("li",[i._v("Open Closed Principle")]),i._v(" "),t("li",[i._v("객체는 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 한다.")])]),i._v(" "),t("h2",{attrs:{id:"lsp-리스코프-치환-원칙"}},[i._v("LSP : 리스코프 치환 원칙")]),i._v(" "),t("ul",[t("li",[i._v("Liscov Substitution Principle")]),i._v(" "),t("li",[i._v("자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다.")]),i._v(" "),t("li",[i._v("부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 동작해야 한다")])]),i._v(" "),t("h2",{attrs:{id:"isp-인터페이스-분리-원칙"}},[i._v("ISP : 인터페이스 분리 원칙")]),i._v(" "),t("ul",[t("li",[i._v("Interface Segregation Principle")]),i._v(" "),t("li",[i._v("??")])]),i._v(" "),t("h2",{attrs:{id:"dip-의존성-역전-원칙"}},[i._v("DIP : 의존성 역전 원칙")]),i._v(" "),t("ul",[t("li",[i._v("Dependency Inversion Principle")]),i._v(" "),t("li",[i._v("추상성이 높고 안정적인 고수준의 클래슨느 구체적이고 불안정한 저수준의 클래스에 의존해서는 안된다.")]),i._v(" "),t("li",[i._v("일반적으로 객체지향의 인터페이스를 통해서 이 원칙을 준수할 ㅅ ㅜ있게 된다.")])])])}],!1,null,null,null);v.options.__file="others-객체지향_5원칙.md";_.default=v.exports}}]);